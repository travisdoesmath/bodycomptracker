<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Body Comp Tracker</title>
  <!-- <link rel="stylesheet" href="style.css"> -->
  <link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/pure-min.css" integrity="sha384-nn4HPE8lTHyVtfCBi5yW9d20FjT8BJwUXyWZT9InLYax14RDjBj46LmSztkmNP9w" crossorigin="anonymous">
  <style>
    html,
    body {
        background: #000;
        color: #AAA;
        font-family: sans-serif;
    }

    .l-box {
        padding: 1em;
    }

    .l2-box {
        padding-left:1em;
        padding-right:1em;
        padding-top: 0;
        padding-bottom: 0;
    }

    h3 {
        margin-bottom: 0;
    }

    .svg-container {
        display: inline-block;
        position: relative;
        width: 100%;
        padding-bottom: 66%;
        vertical-align: top;
        overflow: hidden;
    }

    .svg-content {
        display: inline-block;
        position: absolute;
        top: 0;
        left: 0;
    }

    .axis {
        color: #AAA;
    }
    
    .grid {
        opacity: .25;
        color: #999;
    }

    .line {
        fill: none;
        stroke-width: 2px;
    }

    .obs {
        opacity: 0.5;
    }

    #info {
        display: none;
        padding: 10px;
        border: 1px solid #DDD;
        border-radius: 10px;
        margin-top: 20px;
        margin-bottom: 20px;
    }
    #info p {
        margin: 0
    }
    #info h4 {
        margin: 0 0 10px 0;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.9.2/d3.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.24.0/moment.js"></script>
  <!-- <link href="https://fonts.googleapis.com/css?family=Open+Sans&display=swap" rel="stylesheet"> -->
</head>
<body>
    <div class="pure-g">
        <div class="pure-u-1">
            <div class="l2-box">
                <h3>Current Measurements (7-day projected):</h3>
            </div>
        </div>
        <div class="pure-u-1-4">
            <div class="l-box">
                <span id="weight"></span>
            </div>
        </div>
        <div class="pure-u-1-4">
            <div class="l-box">
                <span id="lean-mass"></h5>
            </div>
        </div>
        <div class="pure-u-1-4">
            <div class="l-box">
                <span id="bfp"></h5>
            </div>
        </div>
        <div class="pure-u-1-4">
            <div class="l-box">
                <span id="bmr"></span>
            </div>
        </div>
        <div class="pure-u-1 pure-u-md-2-3">
        <div class="svg-container">
        </div>
        <div class="pure-u-1">
            <div id="info"></div>
        </div>              
    </div>
  <script>
    var height = 320,
         width = 480

    var svg = d3.select(".svg-container")
        .append("svg")
        .attr("preserveAspectRatio", "xMinYMin meet")
        .attr("viewBox", `0 0 ${width} ${height}`)
        .classed("svg-content", true);

    var defs = svg.append("defs")

    defs.append("pattern")
        .attr("id","lightstripe")
        .attr("patternUnits","userSpaceOnUse")
        .attr("width", "5")
        .attr("height", "5")
        .append("image")
            .attr("xlink:href","data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc1JyBoZWlnaHQ9JzUnPgogIDxyZWN0IHdpZHRoPSc1JyBoZWlnaHQ9JzUnIGZpbGw9J3doaXRlJy8+CiAgPHBhdGggZD0nTTAgNUw1IDBaTTYgNEw0IDZaTS0xIDFMMSAtMVonIHN0cm9rZT0nIzg4OCcgc3Ryb2tlLXdpZHRoPScxJy8+Cjwvc3ZnPg==")
            .attr("x","0")
            .attr("y","0")
            .attr("width","5")
            .attr("height","5")


        .select("svg")

    var margin = {
        top: 10,
        right: 10, 
        bottom: 20,
        left: 30
    }

    var chartWidth = width - margin.left - margin.right;
    var chartHeight = height - margin.top - margin.bottom;

    var axisBreakHeight = 20;

    var g = svg.append("g")
        .attr("transform", `translate(${margin.left}, ${margin.top})`);

    function weightedLeastSquares(X, y, w) {
        var sum_wx = 0,
            sum_wxx = 0,
            sum_wxy = 0,
            sum_wy = 0,
            sum_w = 0;

        for (var i = 0; i < X.length; i++) {
            sum_wx += w[i] * X[i];
            sum_wxx += w[i] * X[i] * X[i];
            sum_wxy += w[i] * X[i] * y[i];
            sum_wy += w[i] * y[i];
            sum_w += w[i]
        }
        var beta = (sum_w*sum_wxy - sum_wx*sum_wy)/(sum_w*sum_wxx - sum_wx*sum_wx);
        var alpha = sum_wy/sum_w - beta * sum_wx/sum_w;

        return {'slope':beta, 'intercept': alpha}
    }

    function median(values) {
        values.sort( function(a,b) {return a - b;} );
        var half = Math.floor(values.length/2);
        if (values.length % 2) {
            return values[half];
        } else {
            return (values[half-1] + values[half]) / 2.0;
        }
    }

    K = x => Math.abs(x) <= 1 ? (15/16)*(1-x)**2 : 0
    T = x => Math.abs(1 - Math.abs(x**3))**3    

    K = x => 1

    function smooth(data, windowInDays) {
        var windowInMilliseconds = windowInDays * 24 * 60 * 60 * 1000;
        
        data.forEach(datum => {
            var subset = data.filter(d => Math.abs(d.measured_at - datum.measured_at) <= windowInMilliseconds)
            x = subset.map(d => (d.measured_at - datum.measured_at)/windowInMilliseconds)
            sample_weights = x.map(d => Math.abs(1 - Math.abs(d**3))**3)
            weight_lb = subset.map(d => d.weight_lb)
            lean_mass_lb = subset.map(d => d.lean_mass_lb)
            weight_reg = weightedLeastSquares(x, weight_lb, sample_weights)
            lean_mass_reg = weightedLeastSquares(x, lean_mass_lb, sample_weights)
            smooth_weight = weight_reg.intercept
            smooth_lean_mass = lean_mass_reg.intercept
            datum['smooth_weight_lb'] = smooth_weight
            datum['smooth_lean_mass_lb'] = smooth_lean_mass
            datum['smooth_bfp'] = 1 - smooth_lean_mass / smooth_weight
            datum['weight_residual'] = datum['weight_lb'] - smooth_weight
            datum['lean_mass_residual'] = datum['lean_mass_lb'] - smooth_lean_mass
        })
    }

    d3.json("http://travs-body-comp-tracker.herokuapp.com/measurements").then(function(data) {
        globalData = data;

        data = data.filter(d => d.lean_mass_lb < 200)

        data.forEach(element => {
            element.measured_at = d3.isoParse(element.measured_at)
        });

        data.sort((a, b) => a.measured_at - b.measured_at)

        smooth(data, 30);
        
        subset = data.filter(d => moment(d.measured_at) > moment().subtract(180, 'day'))

        weightMin = Math.floor(d3.min(subset, d => d.weight_lb)/5)*5
        weightMax = Math.ceil(d3.max(subset, d => d.weight_lb)/5)*5
        leanMassMin = Math.floor(d3.min(subset, d => d.lean_mass_lb)/5)*5
        leanMassMax = Math.ceil(d3.max(subset, d => d.lean_mass_lb)/5)*5

        var xScale = d3.scaleTime()
            .domain(d3.extent(subset, d => d.measured_at))
            .range([0, chartWidth])

        var breakpoint = chartHeight - (chartHeight - axisBreakHeight) * (leanMassMax - leanMassMin) / ((weightMax - weightMin) + (leanMassMax - leanMassMin))

        yScale = d3.scaleLinear()
            .domain([leanMassMin, leanMassMax, weightMin, weightMax])
            .range([chartHeight, breakpoint, breakpoint - axisBreakHeight,0])

        var xAxis = d3.axisBottom(xScale);
        yAxis = d3.axisLeft(yScale)
            .tickValues(d3.range(leanMassMin, leanMassMax + 5, 5).concat(d3.range(weightMin, weightMax + 5, 5)))

        var yGridlines = d3.axisLeft(yScale).tickValues(yAxis.tickValues()).tickSize(-chartWidth).tickFormat("")
        var xGridlines = d3.axisBottom(xScale).tickValues(xAxis.tickValues()).tickSize(chartHeight).tickFormat("")

        g.append("g")
            .classed("grid", true)
            .call(yGridlines)

        g.append("g")
            .classed("grid", true)
            .call(xGridlines)
        
        var weightLine = d3.line()
            .x(d => xScale(d.measured_at))
            .y(d => yScale(d.smooth_weight_lb))

        var leanMassLine = d3.line()
            .x(d => xScale(d.measured_at))
            .y(d => yScale(d.smooth_lean_mass_lb))

        var weightObs = g.selectAll(".weight .obs")
            .data(subset)
            .enter()
            .append("circle")
            .classed("weight", true)
            .classed("obs", true)
            .attr("cx", d => xScale(d.measured_at))
            .attr("cy", d => yScale(d.weight_lb))
            .attr("r", 3)
            .attr("fill", "none")
            .attr("stroke", "yellow")

        var leanMassObs = g.selectAll(".leanmass .obs")
            .data(subset)
            .enter()
            .append("circle")
            .classed("leanmass", true)
            .classed("obs", true)
            .attr("cx", d => xScale(d.measured_at))
            .attr("cy", d => yScale(d.lean_mass_lb))
            .attr("r", 3)
            .attr("fill", "none")
            .attr("stroke", "orange")

        g.append("path")
            .attr("d", weightLine(subset))
            .attr("class", "line")
            .style("stroke", "yellow")

        g.append("path")
            .attr("d", leanMassLine(subset))            
            .attr("class", "line")
            .style("stroke", "orange")

        g.append("g")
            .classed("axis", true)
            .call(yAxis)

        g.append("g")
            .classed("axis", true)
            .attr("transform", `translate(0, ${chartHeight})`)
            .call(xAxis)

        g.append("rect")
            .attr("x", 0)
            .attr("width", chartWidth)
            .attr("y", breakpoint - axisBreakHeight)
            .attr("height", axisBreakHeight)
            .attr("fill", "url(#lightstripe)")
            .attr("opacity", 0.25)


        var weekInMilliseconds = 7 * 24 * 60 * 60 * 1000

        var info = d3.select("#info")

        currentWeight = data[data.length - 1].smooth_weight_lb
        currentLeanMass = data[data.length - 1].smooth_lean_mass_lb
        currentBFP = 1 - currentLeanMass/currentWeight

        weightTrend = (data[data.length - 1].smooth_weight_lb - data[data.length - 2].smooth_weight_lb) * weekInMilliseconds / (data[data.length - 1].measured_at - data[data.length - 2].measured_at)
        leanMassTrend = (data[data.length - 1].smooth_lean_mass_lb - data[data.length - 2].smooth_lean_mass_lb) * weekInMilliseconds / (data[data.length - 1].measured_at - data[data.length - 2].measured_at)
        bfpTrend = (data[data.length - 1].smooth_bfp - data[data.length - 2].smooth_bfp) * weekInMilliseconds / (data[data.length - 1].measured_at - data[data.length - 2].measured_at)

        now = new Date()
        birthday = new Date(1980, 1, 3)
        age = (now - birthday) / (1000 * 60 * 60 * 24 * 365.25)

        BMR_mifflin_st_jeor = 10*(currentWeight * 0.453592) + 6.25*(66*2.54) - 5*age + 5
        BMR_katch_mcardle = 370 + (21.6*currentLeanMass * 0.453592)

        // info.append("p")
        //     .html(`<h4>Current Measurements</h4>
        //            Weight: ${currentWeight.toFixed(1)} lbs<br>
        //            Lean Mass: ${currentLeanMass.toFixed(1)} lbs<br>
        //            BFP: ${currentBFP.toLocaleString(undefined, {style: 'percent', minimumFractionDigits:1})}<br>
        //            BMR: ${50*Math.round(BMR_katch_mcardle/50).toFixed()} kcal<br><hr>
        //            <h4>Projected 7-day trend</h4>
        //            Weight: ${(weightTrend > 0) ? '+' : ''}${weightTrend.toFixed(1)} lbs<br>
        //            Lean Mass: ${(leanMassTrend > 0) ? '+' : ''}${leanMassTrend.toFixed(1)} lbs<br>
        //            BFP: ${bfpTrend.toLocaleString(undefined, {style: 'percent', minimumFractionDigits:1})}`)
        // info.style("display","block")

        d3.select("#weight").text(`WGT: ${currentWeight.toFixed(1)} lbs (${(weightTrend > 0) ? '+' : ''}${weightTrend.toFixed(1)})`)
        d3.select("#lean-mass").text(`LBM: ${currentLeanMass.toFixed(1)} lbs (${(leanMassTrend > 0) ? '+' : ''}${leanMassTrend.toFixed(1)})`)
        d3.select("#bfp").text(`BFP: ${currentBFP.toLocaleString(undefined, {style: 'percent', minimumFractionDigits:1})} (${(bfpTrend > 0) ? '+' : ''}${bfpTrend.toLocaleString(undefined, {style: 'percent', minimumFractionDigits:1})})`)
        d3.select("#bmr").text(`BMR: ${50*Math.round(BMR_katch_mcardle/50).toFixed()} kcal`)
    })

  </script>
</body>
</html>
