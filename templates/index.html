<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Body Comp Tracker</title>
  <!-- <link rel="stylesheet" href="style.css"> -->
  <link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/pure-min.css" integrity="sha384-nn4HPE8lTHyVtfCBi5yW9d20FjT8BJwUXyWZT9InLYax14RDjBj46LmSztkmNP9w" crossorigin="anonymous">
  <style>
    html,
    body {
        background: #000;
        color: #AAA;
        font-family: sans-serif;
    }

    .l-box {
        padding: 1em;
    }

    .l2-box {
        padding-left:1em;
        padding-right:1em;
        padding-top: 0;
        padding-bottom: 0;
    }
 
    #layout {
        position: relative;
        left: 0;
        padding-left: 0;
        min-width: 25em;
    }

    .content {
        margin: 0 auto;
        padding: 0 1em;
        max-width: 800px;
        margin-bottom: 50px;
        line-height: 1.6em;
    }

    h3 {
        margin-bottom: 0;
    }

    .svg-container {
        display: inline-block;
        position: relative;
        width: 100%;
        padding-bottom: 105%;
        vertical-align: top;
        overflow: hidden;
    }

    .svg-content {
        display: inline-block;
        position: absolute;
        top: 0;
        left: 0;
    }

    [class*="axis"] {
        color: #AAA;
    }
    
    [class^="grid"] {
        opacity: .25;
        color: #999;
    }

    [class^="line"] {
        fill: none;
        stroke-width: 2px;
    }

    .obs {
        opacity: 0.5;
    }

    .info-box {
        padding:1em;
        text-align:center;
    }

    .info-box h3 {
        margin-top:0;
        margin-bottom: 0;
    }

    .center {
        text-align: center;
    }

    .pure-button {
        padding: 0.5em;
        border-radius:100em;
        width:3em;
        background-color: #282828;
        color: #AAA;
        border: solid 0.1em;
    }

  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/5.9.2/d3.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.24.0/moment.js"></script>
  <!-- <link href="https://fonts.googleapis.com/css?family=Open+Sans&display=swap" rel="stylesheet"> -->
</head>
<body>
    <div id="layout">
        <div class="content">
            <div class="pure-g">
                <div class="pure-u-1">
                    <h3>Current Measurements (7-day projected):</h3>
                </div>
                <div class="pure-u-1-4">
                    <div id="weight" class="info-box"></div>
                </div>
                <div class="pure-u-1-4">
                    <div id="lean-mass" class="info-box"></div>
                </div>
                <div class="pure-u-1-4">
                    <div id="bfp" class="info-box"></div>
                </div>
                <div class="pure-u-1-4">
                    <div id="bmr" class="info-box"></div>
                </div>
                <div class="pure-u-1">
                <div class="svg-container">
                </div>
                <div class="pure-u-1">
                    <div id="info"></div>
                </div>              
            </div>
            <div id="one-week" class="pure-u-1-5 center">
                <button class="pure-button">1w</button>
            </div>
            <div id="one-month" class="pure-u-1-5 center">
                <button class="pure-button">1m</button>
            </div>
            <div id="three-months" class="pure-u-1-5 center">
                <button class="pure-button">3m</button>
            </div>
            <div id="six-months" class="pure-u-1-5 center">
                <button class="pure-button">6m</button>
            </div>
            <div id="one-year" class="pure-u-1-5 center">
                <button class="pure-button">1y</button>
            </div>
        </div>
    </div>
  <script>
    var globalData;

    var height = 640,
         width = 480

    var svg = d3.select(".svg-container")
        .append("svg")
        .attr("preserveAspectRatio", "xMinYMin meet")
        .attr("viewBox", `0 0 ${width} ${height}`)
        .classed("svg-content", true);

    var defs = svg.append("defs")

    defs.append("pattern")
        .attr("id","lightstripe")
        .attr("patternUnits","userSpaceOnUse")
        .attr("width", "5")
        .attr("height", "5")
        .append("image")
            .attr("xlink:href","data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc1JyBoZWlnaHQ9JzUnPgogIDxyZWN0IHdpZHRoPSc1JyBoZWlnaHQ9JzUnIGZpbGw9J3doaXRlJy8+CiAgPHBhdGggZD0nTTAgNUw1IDBaTTYgNEw0IDZaTS0xIDFMMSAtMVonIHN0cm9rZT0nIzg4OCcgc3Ryb2tlLXdpZHRoPScxJy8+Cjwvc3ZnPg==")
            .attr("x","0")
            .attr("y","0")
            .attr("width","5")
            .attr("height","5")


        .select("svg")

    var margin = {
        top: 10,
        right: 10, 
        bottom: 20,
        left: 30
    }

    var chartWidth = width - margin.left - margin.right;
    var chartHeight = height / 2 - margin.top - margin.bottom;

    var axisBreakHeight = 20;

    var g = svg.append("g")
        .attr("transform", `translate(${margin.left}, ${margin.top})`);

    var bfpG = svg.append("g")
        .attr("transform", `translate(${margin.left}, ${margin.top + height / 2})`)

    function weightedLeastSquares(X, y, w) {
        var sum_wx = 0,
            sum_wxx = 0,
            sum_wxy = 0,
            sum_wy = 0,
            sum_w = 0;

        for (var i = 0; i < X.length; i++) {
            sum_wx += w[i] * X[i];
            sum_wxx += w[i] * X[i] * X[i];
            sum_wxy += w[i] * X[i] * y[i];
            sum_wy += w[i] * y[i];
            sum_w += w[i]
        }
        var beta = (sum_w*sum_wxy - sum_wx*sum_wy)/(sum_w*sum_wxx - sum_wx*sum_wx);
        var alpha = sum_wy/sum_w - beta * sum_wx/sum_w;

        return {'slope':beta, 'intercept': alpha}
    }

    function median(values) {
        values.sort( function(a,b) {return a - b;} );
        var half = Math.floor(values.length/2);
        if (values.length % 2) {
            return values[half];
        } else {
            return (values[half-1] + values[half]) / 2.0;
        }
    }

    K = x => Math.abs(x) <= 1 ? (15/16)*(1-x)**2 : 0
    T = x => Math.abs(1 - Math.abs(x**3))**3    

    K = x => 1

    function smooth(data, windowInDays) {
        var windowInMilliseconds = windowInDays * 24 * 60 * 60 * 1000;
        
        data.forEach(datum => {
            var subset = data.filter(d => Math.abs(d.measured_at - datum.measured_at) <= windowInMilliseconds)
            x = subset.map(d => (d.measured_at - datum.measured_at)/windowInMilliseconds)
            sample_weights = x.map(d => Math.abs(1 - Math.abs(d**3))**3)
            weight_lb = subset.map(d => d.weight_lb)
            lean_mass_lb = subset.map(d => d.lean_mass_lb)
            weight_reg = weightedLeastSquares(x, weight_lb, sample_weights)
            lean_mass_reg = weightedLeastSquares(x, lean_mass_lb, sample_weights)
            smooth_weight = weight_reg.intercept
            smooth_lean_mass = lean_mass_reg.intercept
            datum['smooth_weight_lb'] = smooth_weight
            datum['smooth_lean_mass_lb'] = smooth_lean_mass
            datum['smooth_bfp'] = 1 - smooth_lean_mass / smooth_weight
            datum['weight_residual'] = datum['weight_lb'] - smooth_weight
            datum['lean_mass_residual'] = datum['lean_mass_lb'] - smooth_lean_mass
        })
    }

    function renderCharts(data, subsetFunction) {

        subset = data.filter(subsetFunction);

        weightMin = Math.floor(d3.min(subset, d => d.weight_lb)/5)*5;
        weightMax = Math.ceil(d3.max(subset, d => d.weight_lb)/5)*5;
        leanMassMin = Math.floor(d3.min(subset, d => d.lean_mass_lb)/5)*5;
        leanMassMax = Math.ceil(d3.max(subset, d => d.lean_mass_lb)/5)*5;

        var xScale = d3.scaleTime()
            .domain(d3.extent(subset, d => d.measured_at))
            .range([0, chartWidth])

        var breakpoint = chartHeight - (chartHeight - axisBreakHeight) * (leanMassMax - leanMassMin) / ((weightMax - weightMin) + (leanMassMax - leanMassMin))

        yScale = d3.scaleLinear()
            .domain([leanMassMin, leanMassMax, weightMin, weightMax])
            .range([chartHeight, breakpoint, breakpoint - axisBreakHeight,0])

        bfpYScale = d3.scaleLinear()
            .domain(d3.extent(subset, d => d.fat_percent))
            .range([chartHeight / 2, 0])

        var xAxis = d3.axisBottom(xScale);
        var yAxis = d3.axisLeft(yScale)
            .tickValues(d3.range(leanMassMin, leanMassMax + 5, 5).concat(d3.range(weightMin, weightMax + 5, 5)));
        var bfpYAxis = d3.axisLeft(bfpYScale)
            .tickFormat(d3.format(".0%"))

        var yGridlines = d3.axisLeft(yScale).tickValues(yAxis.tickValues()).tickSize(-chartWidth).tickFormat("")
        var bfpYGridlines = d3.axisLeft(bfpYScale).tickValues(bfpYAxis.tickValues()).tickSize(-chartWidth).tickFormat("")
        var xGridlines = d3.axisBottom(xScale).tickValues(xAxis.tickValues()).tickSize(chartHeight).tickFormat("")
        var bfpXGridlines = d3.axisBottom(xScale).tickValues(xAxis.tickValues()).tickSize(chartHeight / 2).tickFormat("")

        g.selectAll(".grid-y").data([0]).enter().append("g")
            .classed("grid-y", true)
        g.selectAll(".grid-y").transition().call(yGridlines)

        g.selectAll(".grid-x").data([0]).enter().append("g")
            .classed("grid-x", true)
        g.selectAll(".grid-x").transition().call(xGridlines)

        bfpG.selectAll(".grid-y").data([0]).enter().append("g")
            .classed("grid-y", true)
        bfpG.selectAll(".grid-y").transition().call(bfpYGridlines)

        bfpG.selectAll(".grid-x").data([0]).enter().append("g")
            .classed("grid-x", true)
        bfpG.selectAll(".grid-x").transition().call(bfpXGridlines)
        
        var weightLine = d3.line()
            .x(d => xScale(d.measured_at))
            .y(d => yScale(d.smooth_weight_lb))

        var leanMassLine = d3.line()
            .x(d => xScale(d.measured_at))
            .y(d => yScale(d.smooth_lean_mass_lb))

        var bfpLine = d3.line()
            .x(d => xScale(d.measured_at))
            .y(d => bfpYScale(d.smooth_bfp))

        var weightObs = g.selectAll(".weight").filter(".obs")
            .data(subset, d => d.measured_at)

        weightObs.exit()
            .remove()

        weightObs.enter()
            .append("circle")
            .classed("weight", true)
            .classed("obs", true)
            .attr("r", 2)
            .attr("fill", "none")
            .attr("stroke", "#EE0")
          .merge(weightObs)
            .transition()
            .attr("cx", d => xScale(d.measured_at))
            .attr("cy", d => yScale(d.weight_lb))

        var leanMassObs = g.selectAll(".leanmass").filter(".obs")
            .data(subset, d => d.measured_at + d.lean_mass_lb)

        leanMassObs.exit().remove()

        leanMassObs.enter()
            .append("circle")
            .classed("leanmass", true)
            .classed("obs", true)
            .attr("r", 2)
            .attr("fill", "none")
            .attr("stroke", "#F80")
          .merge(leanMassObs)
            .transition()
            .attr("cx", d => xScale(d.measured_at))
            .attr("cy", d => yScale(d.lean_mass_lb))

        var bfpObs = bfpG.selectAll(".bfp").filter(".obs")
            .data(subset)

        bfpObs.exit().remove()

        bfpObs.enter()
            .append("circle")
            .classed("bfp", true)
            .classed("obs", true)
            .attr("r", 2)
            .attr("fill", "none")
            .attr("stroke", "#F40")
          .merge(bfpObs)
            .transition()
            .attr("cx", d => xScale(d.measured_at))
            .attr("cy", d => bfpYScale(d.fat_percent))

        weightLineElement = g.selectAll(".line-weight").data([subset])

        weightLineElement.enter()
            .append("path")
            .classed("line-weight", true)
            .style("stroke", "#EE0")
          .merge(weightLineElement)
            .transition()
            .attr("d", weightLine)

        leanMassLineElement = g.selectAll(".line-leanmass").data([subset])
            
        leanMassLineElement.enter()
            .append("path")
            .attr("class", "line-leanmass")
            .style("stroke", "#F80")
          .merge(leanMassLineElement)
            .transition()
            .attr("d", leanMassLine)            


        bfpLineElement = bfpG.selectAll(".line-bfp").data([subset])
            
        bfpLineElement.enter()
            .append("path")
            .attr("class", "line-bfp")
            .style("stroke", "#E20")
          .merge(bfpLineElement)
            .attr("d", bfpLine)
            

        g.selectAll(".axis-y").data([0]).enter().append("g")
            .classed("axis-y", true)
        g.selectAll(".axis-y").transition().call(yAxis)

        bfpG.selectAll(".axis-x").data([0]).enter().append("g")
            .classed("axis-x", true)
            .attr("transform", `translate(0, ${chartHeight / 2})`)
        bfpG.selectAll(".axis-x").transition().call(xAxis)

        bfpG.selectAll(".axis-y").data([0]).enter().append("g")
            .classed("axis-y", true)
        bfpG.selectAll(".axis-y").transition().call(bfpYAxis)

        g.selectAll(".break").data([0]).enter().append("rect")
            .classed("break", true)
            .attr("fill", "url(#lightstripe)")
            .attr("opacity", 0.25)
        g.selectAll(".break")
            .transition()
            .attr("x", 0)
            .attr("width", chartWidth)
            .attr("y", breakpoint - axisBreakHeight)
            .attr("height", axisBreakHeight)
    }

    function renderData(data) {
        var weekInMilliseconds = 7 * 24 * 60 * 60 * 1000

        var current = data[data.length - 1]

        currentWeight = current.smooth_weight_lb
        currentLeanMass = current.smooth_lean_mass_lb
        currentBFP = 1 - currentLeanMass/currentWeight

        trendPoint = data[data.length - 1]

        var i = -1;
        while (current.measured_at - trendPoint.measured_at < 1000) {
            i--;
            trendPoint = data[data.length + i];
        }

        trendTimeLength = current.measured_at - trendPoint.measured_at

        weightTrend = (current.smooth_weight_lb - trendPoint.smooth_weight_lb) * weekInMilliseconds / trendTimeLength
        leanMassTrend = (current.smooth_lean_mass_lb - trendPoint.smooth_lean_mass_lb) * weekInMilliseconds / trendTimeLength
        bfpTrend = (current.smooth_bfp - trendPoint.smooth_bfp) * weekInMilliseconds / trendTimeLength

        now = new Date()
        birthday = new Date(1980, 1, 3)
        age = (now - birthday) / (1000 * 60 * 60 * 24 * 365.25)

        BMR_mifflin_st_jeor = 10*(currentWeight * 0.453592) + 6.25*(66*2.54) - 5*age + 5
        BMR_katch_mcardle = 370 + (21.6*currentLeanMass * 0.453592)

        d3.select("#weight").html(`Weight<h3>${currentWeight.toFixed(1)}&nbsp;lbs (${(weightTrend > 0) ? '+' : ''}${weightTrend.toFixed(1)})</h3>`)
        d3.select("#lean-mass").html(`LBM<h3>${currentLeanMass.toFixed(1)}&nbsp;lbs (${(leanMassTrend > 0) ? '+' : ''}${leanMassTrend.toFixed(1)})</h3>`)
        d3.select("#bfp").html(`BFP<h3>${currentBFP.toLocaleString(undefined, {style: 'percent', minimumFractionDigits:1})} (${(bfpTrend > 0) ? '+' : ''}${bfpTrend.toLocaleString(undefined, {style: 'percent', minimumFractionDigits:1})})</h3>`)
        d3.select("#bmr").html(`BMR<h3>${50*Math.round(BMR_katch_mcardle/50).toFixed()} kcal</h3>`)
    }

    function processData(data) {
        data = data.filter(d => d.lean_mass_lb < 200)

        data = data.filter(function(item, index) {
            return data.map(d => d.measured_at).indexOf(item.measured_at) >= index;
        })

        data.forEach(element => {
            element.measured_at = d3.isoParse(element.measured_at)
            if (element.fat_percent > 1) {
                element.fat_percent /= 100;
            }
        });

        data.sort((a, b) => a.measured_at - b.measured_at)

        smooth(data, 60);

        return data;
    }

    

    d3.json("http://travs-body-comp-tracker.herokuapp.com/measurements").then(function(data) {
        data = processData(data);
        
        globalData = data;

        renderCharts(data, d => moment(d.measured_at) > moment().subtract(6, 'months'))

        renderData(data)

    })

    d3.select("#one-week").on("click", () => renderCharts(globalData, d => moment(d.measured_at) > moment().subtract(1, 'weeks')))
    d3.select("#one-month").on("click", () => renderCharts(globalData, d => moment(d.measured_at) > moment().subtract(1, 'months')))
    d3.select("#three-months").on("click", () => renderCharts(globalData, d => moment(d.measured_at) > moment().subtract(3, 'months')))
    d3.select("#six-months").on("click", () => renderCharts(globalData, d => moment(d.measured_at) > moment().subtract(6, 'months')))
    d3.select("#one-year").on("click", () => renderCharts(globalData, d => moment(d.measured_at) > moment().subtract(1, 'years')))
    

  </script>
</body>
</html>
